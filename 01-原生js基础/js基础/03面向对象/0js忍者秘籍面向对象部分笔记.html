<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		1 每个对象都可以有一个原型,每个对象的原型也可以拥有一个原型,一次类推,形成一个原型链
		2 创建对象的方式  
			2.1 {} 字面量创建
			2.2 new 构造函数
			2.3 Object.create(新对象的原型，新对象的属性)
			2.4 new Object() constructor函数是Object()
		3 为什么要有构造函数
			3.1 构造函数是用来初始化对象为已知的初始状态 ,  把多个实例对象的属性  归纳起来  
			3.2 毕竟要创建多个相同类型的对象的实例,为每个实例单独进行属性分配,相当繁琐,容易出错
		4 每个函数都有可置的原型对象,可以对其自由更改 函数创建完立即获得一个原型对象
		5 通过new创建新分配的对象,并将其设置为函数的上下文,可以通过this访问,返回的结果是对这个新对象的引用

		<h4>总结</h4>
		<ol>
			<li>通过函数普通调用，没有任何返回值，打印为undefined,也没有原型与原型链</li>
			<li>通过new创建的对象，有原型与原型链</li>
		</ol>
	</body>
	<script>
		// 创建对象最简单的方法就是如下 创建空对象 然后直接给它添加属性
		var obj={};
		obj.name='小明';
		obj.age='24';

		// 例子
		function Ninjia(){}   // 定义一个空函数  什么也不做
		Ninjia.prototype.swingSword=function(){
			return true;
		}
		const ninjia1=Ninjia();

		//false时控制台输出信息
		console.assert(ninjia1!==undefined,'通过普通函数调用，没有任何返回值，所以是undefined')
		console.log(ninjia1)
		// 通过new创建新分配的对象,并将其设置为函数的上下文,可以通过this访问,返回的结果是对这个新对象的引用
		const ninjia2=new Ninjia();
		console.assert(ninjia2&&ninjia2.swingSword&&ninjia2.swingSword(),'作为构造函数调用，验证不仅创建了新的实例，并且实例上具有原型的方法')
		console.log(ninjia2.swingSword)
		console.log(ninjia2.swingSword())
		console.log(ninjia2)
		// 每一个函数的原型都具有一个constructor属性,指向函数本身
		// swingSword方法是Ninjia的原型属性,而不是 ninjia2实例的属性
		
		// 实例属性和原型属性之间的区别

	
		
	</script>
</html>
