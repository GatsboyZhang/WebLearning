<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>创建对象</title>
	</head>
	<body>
			1 JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象
			2 所以打印每一个对象的时候 都会看到一个隐藏的属性__proto__,指向它的原型对象,注意它的原型对象也是一种对象,也会有__proto__
			3 函数的调用是在某个对象上触发的，即调用位置上存在上下文对象
			4 所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已
			5 总结不要随便定义全局的json arr对象 会一直找到所有的属性和方法

		<h4>总结</h4>
		<ol>
			<li>var时，存在变量提升，后面改变了对象的内容，前面的打印内容也会跟着改变</li>
			<li>js每个创建的对象有原型与原型链</li>
		</ol>
	</body>
	<script>
		// 1  JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 
		// 2 所以打印每一个对象的时候 都会看到一个隐藏的属性__proto__,指向它的原型对象,注意它的原型对象也是一种对象,也会有__proto__
		var Student = {
			name: 'Robot',
			height: 1.2,
			run: function() {
				console.log(this);
				console.log(this.name + ' is running...');
			}
		};
		
		// Student.run();  // 隐式调用函数   this指向调用者  也就是执行上下文的所属的对象
		
		// // 3 打印的this ---运行时的对象,所以是Student
		// // 函数的调用是在某个对象上触发的，即调用位置上存在上下文对象  此时的this指向的就是调用方
		// console.log(Student)
		// console.log(Student.__proto__)
		// // 4 Student的原型是object     __proto__指向的是原型对象 object
		// console.log(Student.__proto__.constructor)    // 原型对象身上有个constructor属性  
		// console.log(Student.__proto__.constructor.prototype)   //  原型对象身上的constructor属性身上有个prototype属性  指向Student函数本身
		// console.log(Student.__proto__===Student.__proto__.constructor.prototype)  // 会发现结果是true 
		// console.log(Student.__proto__.constructor===Object)  // Student对象的原型的构造函数是object
		// console.log(Student.__proto__.constructor.prototype.constructor===Object)
		


		console.log('111111111111111111111结束')


        console.log(xiaoming)
	   //  此时var 变量提升  内存中是有xiaoming这个对象 并且被赋值是undefine   直到碰到赋值语句 才有具体的值
		var xiaoming = {
			name: '小明'
		};
		var arr=[1,2,3]

		xiaoming.__proto__ = Student;
		// 5 把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：
		console.log(xiaoming)
		console.log(arr)
		// 6 可以看到 除了xiaoming自身的内容  它的原型是一个对象  对象身上有 name height 属性和run 方法
		// 7 所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已

	
	//     console.log(1);
	//   // 如果你把xiaoming的原型指向其他对象：
		var Bird = {
			fly: function () {
				console.log(this.name + ' is flying...');
			}
		};
		xiaoming.__proto__ = Bird;
		console.log(xiaoming)
		xiaoming.age = '11';
		xiaoming.a=function(){
			alert(1);
		}
		arr[0]='00'
		arr[1]='00'
		arr[2]='00'
		console.log(arr)
		
		// 打印会发现  第一次和第二次打印的xiaoming也变了   原型都变成了Brid   并且都添加了age属性和a方法
		// 这是因为在var的时候 就设置好了xiaoming 这个对象 会去查找所有属性和方法   所以后设置的属性和方法也会在xiaoming身上
		// 总结不要随便定义全局的json arr对象  会一直找到所有的属性和方法   
		//  arr测试了一下   也是  后面改变了对象的内容  在定义后立马打印也会改变  说明js是先收集改对象的所有值  然后再执行的打印
		
		
	</script>
</html>
